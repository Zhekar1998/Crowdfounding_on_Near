{"id":"../node_modules/dag-jose/lib/index.js","dependencies":[{"name":"/home/yevhhenii/Crowdfounding_on_Near/node_modules/dag-jose/lib/index.js.map","includedInParent":true,"mtime":1651056373101},{"name":"/home/yevhhenii/Crowdfounding_on_Near/node_modules/dag-jose/src/index.ts","includedInParent":true,"mtime":1651056373101},{"name":"/home/yevhhenii/Crowdfounding_on_Near/package.json","includedInParent":true,"mtime":1651056382091},{"name":"/home/yevhhenii/Crowdfounding_on_Near/node_modules/dag-jose/package.json","includedInParent":true,"mtime":1651056373101},{"name":"./signing","loc":{"line":26,"column":42},"parent":"/home/yevhhenii/Crowdfounding_on_Near/node_modules/dag-jose/lib/index.js","resolved":"/home/yevhhenii/Crowdfounding_on_Near/node_modules/dag-jose/lib/signing.js"},{"name":"./encryption","loc":{"line":27,"column":45},"parent":"/home/yevhhenii/Crowdfounding_on_Near/node_modules/dag-jose/lib/index.js","resolved":"/home/yevhhenii/Crowdfounding_on_Near/node_modules/dag-jose/lib/encryption.js"},{"name":"@ipld/dag-cbor","loc":{"line":28,"column":34},"parent":"/home/yevhhenii/Crowdfounding_on_Near/node_modules/dag-jose/lib/index.js","resolved":"/home/yevhhenii/Crowdfounding_on_Near/node_modules/@ipld/dag-cbor/cjs/index.js"}],"generated":{"js":"\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decode = exports.encode = exports.toGeneral = exports.code = exports.name = void 0;\nconst signing_1 = __importDefault(require(\"./signing\"));\nconst encryption_1 = __importDefault(require(\"./encryption\"));\nconst cbor = __importStar(require(\"@ipld/dag-cbor\"));\nexports.name = 'dag-jose';\nexports.code = 133;\nfunction isDagJWS(jose) {\n    return ('payload' in jose &&\n        typeof jose.payload === 'string' &&\n        'signatures' in jose &&\n        Array.isArray(jose.signatures));\n}\nfunction isEncodedJWS(jose) {\n    return ('payload' in jose &&\n        jose.payload instanceof Uint8Array &&\n        'signatures' in jose &&\n        Array.isArray(jose.signatures));\n}\nfunction isEncodedJWE(jose) {\n    return ('ciphertext' in jose &&\n        jose.ciphertext instanceof Uint8Array &&\n        'iv' in jose &&\n        jose.iv instanceof Uint8Array &&\n        'protected' in jose &&\n        jose.protected instanceof Uint8Array &&\n        'tag' in jose &&\n        jose.tag instanceof Uint8Array);\n}\nfunction isDagJWE(jose) {\n    return ('ciphertext' in jose &&\n        typeof jose.ciphertext === 'string' &&\n        'iv' in jose &&\n        typeof jose.iv === 'string' &&\n        'protected' in jose &&\n        typeof jose.protected === 'string' &&\n        'tag' in jose &&\n        typeof jose.tag === 'string');\n}\nfunction toGeneral(jose) {\n    if (typeof jose === 'string') {\n        const split = jose.split('.');\n        if (split.length === 3) {\n            return signing_1.default.fromSplit(split);\n        }\n        else if (split.length === 5) {\n            return encryption_1.default.fromSplit(split);\n        }\n        throw new Error('Not a valid JOSE string');\n    }\n    if (isDagJWS(jose) || isDagJWE(jose)) {\n        return jose;\n    }\n    throw new Error('Not a valid unencoded JOSE object');\n}\nexports.toGeneral = toGeneral;\nfunction encode(obj) {\n    if (typeof obj === 'string') {\n        obj = toGeneral(obj);\n    }\n    let encodedJose;\n    if (isDagJWS(obj)) {\n        encodedJose = signing_1.default.encode(obj);\n    }\n    else if (isDagJWE(obj)) {\n        encodedJose = encryption_1.default.encode(obj);\n    }\n    else {\n        throw new Error('Not a valid JOSE object');\n    }\n    return new Uint8Array(cbor.encode(encodedJose));\n}\nexports.encode = encode;\nfunction decode(data) {\n    let encoded;\n    try {\n        encoded = cbor.decode(data);\n    }\n    catch (e) {\n        throw new Error('Not a valid DAG-JOSE object');\n    }\n    if (isEncodedJWS(encoded)) {\n        return signing_1.default.decode(encoded);\n    }\n    else if (isEncodedJWE(encoded)) {\n        return encryption_1.default.decode(encoded);\n    }\n    else {\n        throw new Error('Not a valid DAG-JOSE object');\n    }\n}\nexports.decode = decode;\n"},"sourceMaps":{"js":{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import signing, { DagJWS, EncodedJWS } from './signing'\nexport type { DagJWS } from './signing'\nimport encryption, { DagJWE, EncodedJWE } from './encryption'\nexport type { DagJWE } from './encryption'\nimport * as cbor from '@ipld/dag-cbor'\nimport type { ByteView } from 'multiformats/codecs/interface'\n\n// string name of the codec\nexport const name = 'dag-jose'\n\n// integer for the multiformat entry of the codec\nexport const code = 133 // 0x85 https://github.com/multiformats/multicodec/blob/master/table.csv\n\nfunction isDagJWS(jose: DagJWS | DagJWE | EncodedJWS | EncodedJWE): jose is DagJWS | EncodedJWS {\n  return (\n    'payload' in jose &&\n    typeof jose.payload === 'string' &&\n    'signatures' in jose &&\n    Array.isArray(jose.signatures)\n  )\n}\n\nfunction isEncodedJWS(\n  jose: DagJWS | DagJWE | EncodedJWS | EncodedJWE\n): jose is DagJWS | EncodedJWS {\n  return (\n    'payload' in jose &&\n    jose.payload instanceof Uint8Array &&\n    'signatures' in jose &&\n    Array.isArray(jose.signatures)\n  )\n}\n\nfunction isEncodedJWE(\n  jose: DagJWS | DagJWE | EncodedJWS | EncodedJWE\n): jose is DagJWE | EncodedJWE {\n  return (\n    'ciphertext' in jose &&\n    jose.ciphertext instanceof Uint8Array &&\n    'iv' in jose &&\n    jose.iv instanceof Uint8Array &&\n    'protected' in jose &&\n    jose.protected instanceof Uint8Array &&\n    'tag' in jose &&\n    jose.tag instanceof Uint8Array\n  )\n}\n\nfunction isDagJWE(jose: DagJWS | DagJWE | EncodedJWS | EncodedJWE): jose is DagJWE | EncodedJWE {\n  return (\n    'ciphertext' in jose &&\n    typeof jose.ciphertext === 'string' &&\n    'iv' in jose &&\n    typeof jose.iv === 'string' &&\n    'protected' in jose &&\n    typeof jose.protected === 'string' &&\n    'tag' in jose &&\n    typeof jose.tag === 'string'\n  )\n}\n\n/**\n * Create a properly formed DagJWS or DagJWE object, from either a DagJWS, or\n * DagJWE or the compact string form of either.\n * Applying this function on an already valid DagJWS or DagJWE object will be\n * idempotent. So this function can be used to either verify the proper object\n * form, or expand a compact string form and ensure you have the same form\n * of object that you would receive if you performed a round-trip encode/decode.\n */\nexport function toGeneral(jose: DagJWS | DagJWE | string): DagJWS | DagJWE {\n  if (typeof jose === 'string') {\n    const split = jose.split('.')\n    if (split.length === 3) {\n      return signing.fromSplit(split)\n    } else if (split.length === 5) {\n      return encryption.fromSplit(split)\n    }\n    throw new Error('Not a valid JOSE string')\n  }\n  if (isDagJWS(jose) || isDagJWE(jose)) {\n    return jose\n  }\n  throw new Error('Not a valid unencoded JOSE object')\n}\n\nexport function encode(obj: DagJWS | DagJWE | string): ByteView<EncodedJWS | EncodedJWE> {\n  if (typeof obj === 'string') {\n    obj = toGeneral(obj)\n  }\n  let encodedJose\n  if (isDagJWS(obj)) {\n    encodedJose = signing.encode(obj)\n  } else if (isDagJWE(obj)) {\n    encodedJose = encryption.encode(obj)\n  } else {\n    throw new Error('Not a valid JOSE object')\n  }\n  return new Uint8Array(cbor.encode(encodedJose))\n}\n\nexport function decode(data: ByteView<EncodedJWS | EncodedJWE>): DagJWS | DagJWE {\n  let encoded: EncodedJWS | EncodedJWE\n  try {\n    encoded = cbor.decode(data)\n  } catch (e) {\n    throw new Error('Not a valid DAG-JOSE object')\n  }\n  if (isEncodedJWS(encoded)) {\n    return signing.decode(encoded)\n  } else if (isEncodedJWE(encoded)) {\n    return encryption.decode(encoded)\n  } else {\n    throw new Error('Not a valid DAG-JOSE object')\n  }\n}\n"]}},"error":null,"hash":"d9502c82675f07b7354d0a8de4bf957e","cacheData":{"env":{}}}